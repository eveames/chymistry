'use strict';

/**
 * @ngdoc service
 * @name chemiatriaApp.IonicFormulaFactory
 * @description
 * # IonicFormulaFactory
 * Factory in the chemiatriaApp.
 */
angular.module('chemiatriaApp')
  .factory('IonicFormulaFactory', ['IonListService', 'FormulaService', 'formulaFilter',
   function (IonListService, FormulaService, formulaFilter) {
    // Service logic
    // ...

    // Public API here
    return {
      // subtypes: acid, single salt, poly salt 
      // usually asks for formula, occasionally name
      // PL factory

      getQuestion : function(type, subtype, level) {
        
        var qToReturn = {type: type, hasImage: false, qHint: ['Sorry, no hints yet. Enter 0 to see the answer and move on.']};
        qToReturn.factOrSkill = 'skill';
        var formulaEx = formulaFilter('Ru(CO)6');
        qToReturn.instructions = 'If you don\'t know the answer, enter 0 (zero). ' +
            'The answer will be displayed, and you\'ll see it again soon. ' +
            'Answers are case-sensitive. Names are mostly lower-case, except roman numerals. Use the acid names where ' +
            'appropriate, not the molecular names. To enter a formula, type it as you would write it. Be careful with parentheses! ' +
            'Example: ('+formulaEx + '): "Ru(CO)6". You\'ll see your answer with formatting in the box. ';
        qToReturn.qBackgroundText = 'Note that the compounds in these problems are generated by an ' +
            'algorithm with unsophisticated (dumb!) chemical logic. They may not all exist in real life,' +
            ' because not all anions form stable compounds with all cations.';
        qToReturn.showBackgroundText = true;
        
        //var name = idParseArray[2];
        var answerArray = [];
        
        // get the name, formula 
        var formulaObj = {};
        var anIndex, catIndex, anions, cations, catName, catCharge, catFormula;
        var romanNums = ['','I','II','III','IV','V','VI','VII', 'VIII'];
        switch (subtype) {
          case 'acid':
            var acids = IonListService.acids(level);
            anIndex = Math.floor(Math.random() * acids.length);
            formulaObj.name = acids[anIndex].acid + ' acid';
            formulaObj.formula = FormulaService.getSaltFormula('H+1', acids[anIndex].formula);
            break;
          case 'single salt':
          case 'poly salt':
            anions = IonListService.anions();
            cations = IonListService.cations();
            if (subtype === 'poly salt') {
              anions.concat(IonListService.polyanions(level));
              cations.concat(IonListService.polycations(level));
            }
            anIndex = Math.floor(Math.random() * anions.length);
            catIndex = Math.floor(Math.random() * cations.length);
            if (cations[catIndex].romNum) {

              catCharge = cations[catIndex].charge[Math.floor(Math.random() * cations[catIndex].charge.length)];
              catName = cations[catIndex].name + '(' + romanNums[catCharge] + ')';
            }
            else {
              catName = cations[catIndex].name;
              catCharge = cations[catIndex].charge;
            }

            catFormula = cations[catIndex].formula + '+' + catCharge;

            formulaObj.name = catName + ' ' + anions[anIndex].name;
            formulaObj.formula = FormulaService.getSaltFormula(catFormula, anions[anIndex].formula); 
            break;
          default: 
            console.log('hit default in ionic formula switch');
        }

        var which = Math.floor(Math.random() * 4);

        //console.log('in vocabFactory:', idParseArray);
        
        //if (word !== entry.word) {console.log('index does not match word');}

        // give name, ask for formula
        if (which) {
          qToReturn.qPrompt = formulaObj.name;
          qToReturn.qText = 'Give the formula of ' + qToReturn.qPrompt + ':';

          answerArray[0] = {alt: formulaObj.formula, correct: 'correct', message: ''};
          qToReturn.qAnswerFormat = 'formula-box';
          /*if (typeof entry.alts === 'object' && entry.alts.length > 0) {
            for (i = 0; i < entry.alts.length; i++) {
              answerObj = {alt: entry.alts[i].formula, correct: entry.alts[i].correct};
              if (entry.alts[i].correct === 'close') {
                answerObj.message = 'Careful! That\'s ' + entry.alts[i].name + '.';
              }
              answerArray.push(answerObj);
            }
          }*/
        } 

        //give formula, ask for name
        else {
          qToReturn.qPrompt = formulaFilter(formulaObj.formula);
          qToReturn.qText = 'Give the name of ' + qToReturn.qPrompt + ':';
          answerArray[0] = {alt: formulaObj.name, correct: 'correct', message: ''};
          qToReturn.qAnswerFormat = 'small-text-box';
          /*if (typeof entry.alts === 'object' && entry.alts.length > 0) {
            for (i = 0; i < entry.alts.length; i++) {
              answerObj = {alt: entry.alts[i].name, correct: entry.alts[i].correct};
              if (entry.alts[i].correct === 'close') {
                answerObj.message = 'Careful! That\'s ' + entry.alts[i].formula + '.';
              }
              answerArray.push(answerObj);
            }
          }*/
        }
        console.log('answerArray is', answerArray);
        qToReturn.qAnswer = answerArray;
        qToReturn.responseToWrong = ['Try again: ', 
        'Answer to "' + qToReturn.qPrompt + '" is "' + qToReturn.qAnswer[0].alt + '." We\'ll come back to it.'];
        qToReturn.qID = type + '-' + subtype + '-' + formulaObj.name;

        // correctAnswer is an array containing prompt and certain alternates
        qToReturn.checkMethod = function(correctAnswer, givenAnswer) {
          var answerDetailToReturn = {answer: givenAnswer, messageSent: '', correct: ''};
          //console.log('correct is: ', correctAnswer);
          //console.log('correct length: ', correctAnswer.length);
          //console.log('given is: ', givenAnswer);

          //set correct (correct/close/knownWrong/unknownWrong/noAnswer/formatError/dontKnow)
          //check for no answer
          if (!givenAnswer) {
            answerDetailToReturn.correct = 'noAnswer';
            answerDetailToReturn.messageSent = 'If you don\'t know the answer, enter zero. ';
          }
          else if (Number(givenAnswer) === 0) {
            answerDetailToReturn.correct = 'dontKnow';
          }

          if (!givenAnswer.match(/^[\w()]+$/g) && correctAnswer[0].alt.match(/^[\w()]+$/g)) {
            answerDetailToReturn.correct = 'formatError';
            answerDetailToReturn.messageSent = 'Use only letters, numbers and (). ';
          }      
                
          else {
            for (var i = 0; i < correctAnswer.length ; i++){
              //console.log('i is ', i);
              if (givenAnswer === correctAnswer[i].alt) {
                answerDetailToReturn.correct = correctAnswer[i].correct;
                if (correctAnswer[i].message) {answerDetailToReturn.messageSent = correctAnswer[i].message + ' ';}
                break;
              }

              if (correctAnswer[i].correct === 'correct') {
                var formatCheck = givenAnswer.toLowerCase().replace(/[()]/g, '');
                var answerNoFormat = correctAnswer[i].alt.toLowerCase().replace(/[()]/g, '');

                if (formatCheck === answerNoFormat) {
                  answerDetailToReturn.correct = 'formatError';
                  answerDetailToReturn.messageSent = 'Almost there, please check your capitalization and/or parentheses. ';
                  break;
                }
              }
            }
            if (!answerDetailToReturn.correct) {
              answerDetailToReturn.correct = 'unknownWrong';
              answerDetailToReturn.messageSent = 'I don\'t recognize your answer. Type carefully! ';
            }
          }

          //console.log(answerDetailToReturn.detail);
          return answerDetailToReturn;
        };


      return qToReturn;
      }
    };
  }]);
